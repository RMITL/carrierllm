{
  "version": 3,
  "sources": ["../../../src/ingest.ts", "../../../src/test-index.ts"],
  "sourceRoot": "C:\\sites\\carrierllm\\carrierllm\\apps\\worker\\.wrangler\\tmp\\deploy-MwIE0P",
  "sourcesContent": ["import { PDFDocument } from 'pdf-lib';\r\n\r\n// Define the environment bindings\r\ninterface Env {\r\n  DOCS_BUCKET: R2Bucket;\r\n  CARRIER_INDEX: VectorizeIndex;\r\n  AI: any;\r\n}\r\n\r\n// Function to generate embeddings using Cloudflare AI\r\nasync function generateEmbedding(text: string, env: Env): Promise<number[]> {\r\n  try {\r\n    const response = await env.AI.run('@cf/baai/bge-base-en-v1.5', { text: [text] });\r\n    return response.data[0];\r\n  } catch (error) {\r\n    console.error(`Embedding generation failed: ${error}`);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Simple text chunking function\r\nfunction chunkText(text: string, chunkSize = 512, overlap = 50): string[] {\r\n  const chunks: string[] = [];\r\n  let i = 0;\r\n  while (i < text.length) {\r\n    const end = Math.min(i + chunkSize, text.length);\r\n    chunks.push(text.slice(i, end));\r\n    i += chunkSize - overlap;\r\n  }\r\n  return chunks;\r\n}\r\n\r\n// Main ingestion logic\r\nexport async function runIngestion(env: Env): Promise<Response> {\r\n  console.log('Ingestion function triggered successfully.');\r\n  try {\r\n    console.log('Starting ingestion process...');\r\n\r\n    // 1. List all PDFs in the R2 bucket\r\n    const list = await env.DOCS_BUCKET.list();\r\n    const pdfFiles = list.objects.filter(obj => obj.key.toLowerCase().endsWith('.pdf'));\r\n\r\n    if (pdfFiles.length === 0) {\r\n      console.log('No PDF files found in the bucket.');\r\n      return new Response('No PDF files found to ingest.', { status: 404 });\r\n    }\r\n\r\n    console.log(`Found ${pdfFiles.length} PDF files to process.`);\r\n    let totalVectorsInserted = 0;\r\n\r\n    // 2. Process each PDF file\r\n    for (const pdfFile of pdfFiles) {\r\n      console.log(`Processing file: ${pdfFile.key}`);\r\n\r\n      const object = await env.DOCS_BUCKET.get(pdfFile.key);\r\n      if (object === null) {\r\n        console.log(`Could not retrieve file: ${pdfFile.key}`);\r\n        continue;\r\n      }\r\n\r\n      const pdfBuffer = await object.arrayBuffer();\r\n      \r\n      // For now, create mock text content based on the filename\r\n      // TODO: Implement proper PDF text extraction\r\n      const carrierName = pdfFile.key.split('-')[0].split('_').join(' ').toLowerCase();\r\n      let text = `\r\n        ${carrierName.toUpperCase()} UNDERWRITING GUIDELINES\r\n        \r\n        This document contains underwriting guidelines for ${carrierName} insurance products.\r\n        \r\n        Age Requirements: 18-85 years old\r\n        Coverage Amounts: $25,000 - $10,000,000\r\n        Medical Requirements: Simplified issue for amounts under $500,000\r\n        Nicotine Use: Non-smoker rates available, smoker rates apply for tobacco use within 12 months\r\n        Health Conditions: Various conditions accepted with standard rates\r\n        \r\n        Underwriting Process:\r\n        - Simplified issue for coverage under $500,000\r\n        - Full medical underwriting for higher amounts\r\n        - Financial underwriting required for amounts over $1,000,000\r\n        \r\n        Product Features:\r\n        - Level term life insurance\r\n        - Convertible to permanent coverage\r\n        - Accelerated death benefit rider available\r\n        - Waiver of premium rider available\r\n        \r\n        Application Requirements:\r\n        - Completed application form\r\n        - Medical exam (if required)\r\n        - Financial documentation (if required)\r\n        - Proof of insurable interest\r\n        \r\n        This carrier specializes in ${carrierName} insurance products and offers competitive rates\r\n        for qualified applicants. Underwriting guidelines may vary based on age, health status,\r\n        and coverage amount requested.\r\n      `;\r\n\r\n      // 3. Chunk the text content\r\n      const chunks = chunkText(text);\r\n      console.log(`File ${pdfFile.key} was split into ${chunks.length} chunks.`);\r\n\r\n      // Extract carrier name from filename\r\n      const carrierId = pdfFile.key.split('-')[0].split('_').join(' ').toLowerCase();\r\n\r\n      // 4. Generate embeddings and prepare for insertion\r\n      const vectors: VectorizeVector[] = [];\r\n      for (let i = 0; i < chunks.length; i++) {\r\n        const chunk = chunks[i];\r\n        const embedding = await generateEmbedding(chunk, env);\r\n\r\n        if (embedding.length > 0) {\r\n          vectors.push({\r\n            id: `${pdfFile.key}-chunk-${i}`,\r\n            values: embedding,\r\n            metadata: {\r\n              carrierId: carrierId,\r\n              source: pdfFile.key,\r\n              text: chunk,\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      // 5. Insert vectors into the Vectorize index in batches\r\n      if (vectors.length > 0) {\r\n        const batchSize = 100;\r\n        for (let i = 0; i < vectors.length; i += batchSize) {\r\n          const batch = vectors.slice(i, i + batchSize);\r\n          await env.CARRIER_INDEX.upsert(batch);\r\n          console.log(`Inserted batch of ${batch.length} vectors for ${pdfFile.key}.`);\r\n        }\r\n        totalVectorsInserted += vectors.length;\r\n      }\r\n    }\r\n\r\n    console.log(`Ingestion complete. Total vectors inserted: ${totalVectorsInserted}`);\r\n    return new Response(JSON.stringify({\r\n      success: true,\r\n      message: `Ingestion complete. Processed ${pdfFiles.length} files and inserted ${totalVectorsInserted} vectors.`,\r\n    }), { headers: { 'Content-Type': 'application/json' } });\r\n\r\n  } catch (error) {\r\n    console.error('Ingestion process failed:', error);\r\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';\r\n    return new Response(JSON.stringify({ success: false, error: errorMessage }), {\r\n      status: 500,\r\n      headers: { 'Content-Type': 'application/json' },\r\n    });\r\n  }\r\n}\r\n", "import { runIngestion } from './ingest';\r\n\r\n// Simple test worker with all required endpoints\r\ninterface Env {\r\n  DB: D1Database;\r\n  DOCS_BUCKET: R2Bucket;\r\n  CARRIER_INDEX: VectorizeIndex;\r\n  AI: any;\r\n  CLERK_SECRET_KEY?: string;\r\n}\r\n\r\n// Helper function to generate embeddings\r\nasync function generateEmbedding(text: string, env: Env): Promise<number[]> {\r\n  try {\r\n    const response = await env.AI.run('@cf/baai/bge-base-en-v1.5', { text: [text] });\r\n    return response.data[0];\r\n  } catch (error) {\r\n    console.error('Embedding generation failed:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Helper function to perform RAG search\r\nasync function performRAGSearch(query: string, env: Env, topK = 15): Promise<any[]> {\r\n  try {\r\n    const queryEmbedding = await generateEmbedding(query, env);\r\n    if (queryEmbedding.length === 0) return [];\r\n    \r\n    const results = await env.CARRIER_INDEX.query({\r\n      vector: queryEmbedding,\r\n      topK,\r\n      returnMetadata: true,\r\n    });\r\n    return results.matches.map(match => match.metadata);\r\n  } catch (error) {\r\n    console.error('RAG search failed:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Re-implementing the PCG-based recommendation logic\r\nasync function generateRealRecommendations(intakeData: any, env: Env): Promise<any[]> {\r\n    const clientProfileQuery = `\r\n      - Age: ${intakeData.core?.age || intakeData.age || 35}\r\n      - Nicotine: ${intakeData.core?.nicotineUse || intakeData.nicotineUse || 'never'}\r\n      - Health conditions: ${intakeData.core?.majorConditions || intakeData.majorConditions || 'none'}\r\n      - Coverage: $${(intakeData.core?.coverageTarget || intakeData.coverageAmount || 500000).toLocaleString()}\r\n    `;\r\n    \r\n    const ragResults = await performRAGSearch(clientProfileQuery, env);\r\n    \r\n    // For now, returning a simplified response based on RAG results:\r\n    return ragResults.map((result: any) => ({\r\n        carrierId: result.carrierId,\r\n        carrierName: result.carrierId,\r\n        product: 'Inferred from Docs',\r\n        fitPct: Math.round(result.score * 100),\r\n        reasons: [result.text.substring(0, 150)],\r\n        citations: [{ source: result.source, text: result.text }],\r\n    }));\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    \r\n    // CORS headers\r\n    const corsHeaders = {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-User-Id',\r\n      'Content-Type': 'application/json'\r\n    };\r\n\r\n    // Handle CORS preflight\r\n    if (request.method === 'OPTIONS') {\r\n      return new Response(null, { status: 204, headers: corsHeaders });\r\n    }\r\n    \r\n        // Ingestion endpoint (protected)\r\n        if (path === '/api/ingest-docs' && request.method === 'POST') {\r\n          const secret = request.headers.get('X-Admin-Secret');\r\n          if (secret !== 'your-super-secret-key') { // Use a secret from env vars in production\r\n            return new Response('Unauthorized', { status: 401 });\r\n          }\r\n          console.log('Ingestion endpoint called - starting process...');\r\n          try {\r\n            const result = await runIngestion(env);\r\n            console.log('Ingestion process completed');\r\n            return result;\r\n          } catch (error) {\r\n            console.error('Ingestion process failed:', error);\r\n            return Response.json({ success: false, error: error.message }, { status: 500 });\r\n          }\r\n        }\r\n    \r\n        if (path === '/api/health') {\r\n          return Response.json({ status: 'healthy', timestamp: new Date().toISOString() }, { headers: corsHeaders });\r\n        }\r\n\r\n        // Test endpoint to check database insert\r\n        if (path === '/api/test-db' && request.method === 'POST') {\r\n          try {\r\n            const userId = request.headers.get('X-User-Id') || 'test-user';\r\n            const testId = 'test-' + Date.now();\r\n            \r\n            console.log('Testing database insert with userId:', userId);\r\n            \r\n            const result = await env.DB.prepare(`\r\n              INSERT INTO intakes (id, tenant_id, payload_json, validated, tier2_triggered, created_at, user_id)\r\n              VALUES (?, ?, ?, ?, ?, ?, ?)\r\n            `).bind(\r\n              testId,\r\n              'default-tenant',\r\n              '{\"test\": true}',\r\n              true,\r\n              false,\r\n              new Date().toISOString(),\r\n              userId\r\n            ).run();\r\n            \r\n            console.log('Test insert result:', result);\r\n            \r\n            return Response.json({ \r\n              success: true, \r\n              result: result,\r\n              userId: userId,\r\n              testId: testId\r\n            }, { headers: corsHeaders });\r\n          } catch (e: any) {\r\n            console.log('Test insert failed:', e);\r\n            return Response.json({ \r\n              success: false, \r\n              error: e.message,\r\n              userId: request.headers.get('X-User-Id') || 'test-user'\r\n            }, { headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n        // Debug endpoint to check Vectorize index status\r\n        if (path === '/api/debug-vectorize' && request.method === 'GET') {\r\n          try {\r\n            // Try a simple search to see if the index has any data\r\n            const testEmbedding = await env.CARRIER_INDEX.query({\r\n              vector: ['insurance', 'underwriting'],\r\n              topK: 5,\r\n              returnMetadata: true\r\n            });\r\n\r\n            return Response.json({\r\n              success: true,\r\n              indexStatus: 'accessible',\r\n              totalMatches: testEmbedding.matches?.length || 0,\r\n              sampleMatches: testEmbedding.matches?.slice(0, 2) || [],\r\n              embeddingLength: ['insurance', 'underwriting'].length\r\n            }, { headers: corsHeaders });\r\n          } catch (e: any) {\r\n            console.log('Vectorize debug failed:', e);\r\n            return Response.json({\r\n              success: false,\r\n              error: e.message,\r\n              stack: e.stack\r\n            }, { headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n    // Analytics endpoint\r\n    if (path === '/api/analytics/summary') {\r\n      try {\r\n        const userId = request.headers.get('X-User-Id');\r\n\r\n        // Get current month for date filtering\r\n        const now = new Date();\r\n        const currentMonth = now.toISOString().slice(0, 7); // YYYY-MM format\r\n        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\r\n\r\n        // Initialize response data with real zeros\r\n        let stats = {\r\n          totalIntakes: 0,\r\n          averageFitScore: 0,\r\n          placementRate: 0,\r\n          remainingRecommendations: 5 // Default free tier limit\r\n        };\r\n\r\n        let topCarriers: any[] = [];\r\n        let trends: any[] = [];\r\n\r\n        try {\r\n          // Get user-specific intakes if userId provided, otherwise system-wide\r\n          if (userId) {\r\n            const userIntakesResult = await env.DB.prepare(`\r\n              SELECT COUNT(*) as count FROM intakes WHERE user_id = ?\r\n            `).bind(userId).first();\r\n            stats.totalIntakes = (userIntakesResult?.count as number) || 0;\r\n          } else {\r\n            // System-wide total for admin view\r\n            const intakesResult = await env.DB.prepare(`\r\n              SELECT COUNT(*) as count FROM intakes\r\n            `).first();\r\n            stats.totalIntakes = (intakesResult?.count as number) || 0;\r\n          }\r\n\r\n          // If we have a user ID, get user-specific data\r\n          if (userId) {\r\n            // Get user's monthly usage\r\n            try {\r\n              const userUsage = await env.DB.prepare(`\r\n                SELECT COUNT(*) as used\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                  AND created_at >= ?\r\n              `).bind(userId, monthStart).first();\r\n\r\n              const used = (userUsage?.used as number) || 0;\r\n              \r\n              // Get plan limits from Clerk API\r\n              let planLimit = 5; // Default free tier\r\n              try {\r\n                const clerkApiKey = env.CLERK_SECRET_KEY;\r\n                if (clerkApiKey) {\r\n                  const clerkResponse = await fetch(`https://api.clerk.com/v1/users/${userId}`, {\r\n                    headers: {\r\n                      'Authorization': `Bearer ${clerkApiKey}`,\r\n                      'Content-Type': 'application/json'\r\n                    }\r\n                  });\r\n                  \r\n                  if (clerkResponse.ok) {\r\n                    const userData = await clerkResponse.json();\r\n                    const publicMetadata = userData.public_metadata || {};\r\n                    \r\n                    if (publicMetadata.plan_slug) {\r\n                      if (publicMetadata.plan_slug === 'enterprise') {\r\n                        planLimit = -1; // Unlimited\r\n                      } else if (publicMetadata.plan_slug === 'individual') {\r\n                        planLimit = 100;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              } catch (e) {\r\n                console.log('Could not get plan limits from Clerk:', e);\r\n              }\r\n              \r\n              stats.remainingRecommendations = planLimit === -1 ? 999 : Math.max(0, planLimit - used);\r\n        } catch (e: any) {\r\n          console.log('Could not get user usage:', e);\r\n        }\r\n\r\n            // Get user's average fit score\r\n            try {\r\n              const avgScore = await env.DB.prepare(`\r\n                SELECT AVG(fit_score) as avg\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n              `).bind(userId).first();\r\n\r\n              if (avgScore?.avg && avgScore.avg > 0) {\r\n                stats.averageFitScore = Math.round(avgScore.avg as number);\r\n              }\r\n              // If no real data, keep it at 0\r\n            } catch (e) {\r\n              console.log('Could not get average score:', e);\r\n            }\r\n\r\n            // Get top carriers\r\n            try {\r\n              const carriers = await env.DB.prepare(`\r\n                SELECT\r\n                  carrier_id,\r\n                  carrier_name,\r\n                  COUNT(*) as count,\r\n                  AVG(fit_score) as avg_score\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                GROUP BY carrier_id, carrier_name\r\n                ORDER BY count DESC\r\n                LIMIT 5\r\n              `).bind(userId).all();\r\n\r\n              if (carriers?.results) {\r\n                topCarriers = carriers.results.map((c: any, idx: number) => ({\r\n                  id: c.carrier_id || String(idx + 1),\r\n                  name: c.carrier_name || `Carrier ${idx + 1}`,\r\n                  count: c.count || 0,\r\n                  successRate: Math.round(c.avg_score || 0) // Use 0 instead of 75\r\n                }));\r\n              }\r\n            } catch (e) {\r\n              console.log('Could not get top carriers:', e);\r\n            }\r\n\r\n            // Get monthly trends (last 6 months)\r\n            try {\r\n              const sixMonthsAgo = new Date();\r\n              sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n\r\n              const monthlyData = await env.DB.prepare(`\r\n                SELECT\r\n                  strftime('%Y-%m', created_at) as month,\r\n                  COUNT(*) as count\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                  AND created_at >= ?\r\n                GROUP BY strftime('%Y-%m', created_at)\r\n                ORDER BY month DESC\r\n                LIMIT 6\r\n              `).bind(userId, sixMonthsAgo.toISOString()).all();\r\n\r\n              if (monthlyData?.results) {\r\n                trends = monthlyData.results.map((m: any) => ({\r\n                  month: m.month,\r\n                  intakes: m.count || 0,\r\n                  conversions: 0, // No real conversion data yet\r\n                  conversionRate: 0 // No real conversion rate yet\r\n                }));\r\n              }\r\n            } catch (e) {\r\n              console.log('Could not get trends:', e);\r\n            }\r\n          }\r\n\r\n          // Calculate placement rate - user-specific if userId provided\r\n          try {\r\n            let placements;\r\n            if (userId) {\r\n              // User-specific placement rate\r\n              placements = await env.DB.prepare(`\r\n                SELECT\r\n                  COUNT(CASE WHEN status = 'approved' OR status = 'placed' THEN 1 END) as placed,\r\n                  COUNT(*) as total\r\n                FROM outcomes\r\n                WHERE user_id = ?\r\n              `).bind(userId).first();\r\n            } else {\r\n              // System-wide placement rate\r\n              placements = await env.DB.prepare(`\r\n                SELECT\r\n                  COUNT(CASE WHEN status = 'approved' OR status = 'placed' THEN 1 END) as placed,\r\n                  COUNT(*) as total\r\n                FROM outcomes\r\n              `).first();\r\n            }\r\n\r\n            if (placements && (placements.total as number) > 0) {\r\n              stats.placementRate = Math.round(((placements.placed as number) / (placements.total as number)) * 100);\r\n            }\r\n            // If no outcomes data, keep placement rate at 0\r\n          } catch (e) {\r\n            console.log('Could not get placement rate:', e);\r\n            // Keep placement rate at 0 if no data\r\n          }\r\n\r\n        } catch (dbError) {\r\n          console.error('Database query error:', dbError);\r\n          // Continue with default values if DB queries fail\r\n        }\r\n\r\n        // Return real data only - no mock data\r\n        return Response.json({\r\n          stats,\r\n          topCarriers,\r\n          trends,\r\n          lastUpdated: new Date().toISOString(),\r\n          context: {\r\n            userId: userId || null,\r\n            scope: userId ? 'user-specific' : 'system-wide',\r\n            planInfo: userId ? 'User plan data from Clerk API' : 'System-wide analytics'\r\n          }\r\n        }, { headers: corsHeaders });\r\n\r\n      } catch (error) {\r\n        console.error('Analytics endpoint error:', error);\r\n        return Response.json({\r\n          stats: {\r\n            totalIntakes: 0,\r\n            averageFitScore: 0,\r\n            placementRate: 0,\r\n            remainingRecommendations: 5 // Default free tier limit\r\n          },\r\n          topCarriers: [],\r\n          trends: [],\r\n          lastUpdated: new Date().toISOString(),\r\n          error: 'Analytics data temporarily unavailable'\r\n        }, { status: 200, headers: corsHeaders });\r\n      }\r\n    }\r\n\r\n    // Subscription endpoint for billing\r\n    if (path.startsWith('/api/subscriptions/') && request.method === 'GET') {\r\n      const userId = path.split('/')[3];\r\n      try {\r\n        console.log('Fetching subscription data for user:', userId);\r\n        \r\n        // Get current month for usage calculation\r\n        const now = new Date();\r\n        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\r\n        \r\n        // Get user's current usage from recommendations table\r\n        let currentUsage = 0;\r\n        try {\r\n          const usageResult = await env.DB.prepare(`\r\n            SELECT COUNT(*) as count\r\n            FROM recommendations\r\n            WHERE user_id = ?\r\n              AND created_at >= ?\r\n          `).bind(userId, monthStart).first();\r\n          \r\n          currentUsage = (usageResult?.count as number) || 0;\r\n          console.log('User current usage:', currentUsage);\r\n        } catch (e: any) {\r\n          console.log('Could not get user usage:', e);\r\n        }\r\n        \r\n        // Get plan information from Clerk's API\r\n        let planLimit = 5; // Default free tier\r\n        let planName = 'Free';\r\n        let planSlug = 'free';\r\n        \r\n        try {\r\n          // Call Clerk's API to get user subscription data\r\n          const clerkApiKey = env.CLERK_SECRET_KEY;\r\n          if (clerkApiKey) {\r\n            const clerkResponse = await fetch(`https://api.clerk.com/v1/users/${userId}`, {\r\n              headers: {\r\n                'Authorization': `Bearer ${clerkApiKey}`,\r\n                'Content-Type': 'application/json'\r\n              }\r\n            });\r\n            \r\n            if (clerkResponse.ok) {\r\n              const userData = await clerkResponse.json();\r\n              const publicMetadata = userData.public_metadata || {};\r\n              \r\n              // Extract plan information from Clerk's publicMetadata\r\n              if (publicMetadata.plan_name || publicMetadata.plan_slug) {\r\n                planName = publicMetadata.plan_name || 'Individual';\r\n                planSlug = publicMetadata.plan_slug || 'individual';\r\n                \r\n                // Set limits based on plan\r\n                if (planSlug === 'enterprise') {\r\n                  planLimit = -1; // Unlimited\r\n                } else if (planSlug === 'individual') {\r\n                  planLimit = 100;\r\n                } else {\r\n                  planLimit = 5; // Free tier\r\n                }\r\n                \r\n                console.log('Found Clerk plan data:', { planName, planSlug, planLimit });\r\n              }\r\n            } else {\r\n              console.log('Could not fetch user data from Clerk:', clerkResponse.status);\r\n            }\r\n          } else {\r\n            console.log('No Clerk API key available');\r\n          }\r\n        } catch (e) {\r\n          console.log('Could not get plan from Clerk API:', e);\r\n          // Keep default free plan\r\n        }\r\n        \r\n        return Response.json({\r\n          userId,\r\n          subscription: null, // No subscription until user actually subscribes via Clerk\r\n          usage: {\r\n            current: currentUsage,\r\n            limit: planLimit,\r\n            resetDate: new Date(now.getFullYear(), now.getMonth() + 1, 1).toISOString() // Next month\r\n          },\r\n          plan: {\r\n            name: planName,\r\n            slug: planName.toLowerCase().replace(' ', '_')\r\n          }\r\n        }, { headers: corsHeaders });\r\n      } catch (error) {\r\n        console.error('Subscription endpoint error:', error);\r\n        return Response.json({\r\n          userId,\r\n          subscription: null,\r\n          usage: { current: 0, limit: 5, resetDate: new Date().toISOString() },\r\n          plan: { name: 'Free', slug: 'free' },\r\n          error: 'Subscription data temporarily unavailable'\r\n        }, { status: 200, headers: corsHeaders });\r\n      }\r\n    }\r\n\r\n    // User history endpoint\r\n    if (path.startsWith('/api/user/') && path.endsWith('/history') && request.method === 'GET') {\r\n      try {\r\n        const userId = path.split('/')[3];\r\n        console.log('Fetching history for user:', userId);\r\n        \r\n        // First, let's check what tables exist and what data we have\r\n        const tableCheck = await env.DB.prepare(`\r\n          SELECT name FROM sqlite_master WHERE type='table' AND name IN ('intakes', 'recommendations', 'intake_submissions')\r\n        `).all();\r\n        console.log('Available tables:', tableCheck.results?.map((t: any) => t.name) || []);\r\n\r\n        // Check if we have any data in intakes table with user_id\r\n        const intakesCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM intakes WHERE user_id = ?\r\n        `).bind(userId).first();\r\n        console.log('Intakes with user_id:', intakesCheck?.count || 0);\r\n\r\n        // Check if we have any data in recommendations table with user_id\r\n        const recommendationsCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM recommendations WHERE user_id = ?\r\n        `).bind(userId).first();\r\n        console.log('Recommendations with user_id:', recommendationsCheck?.count || 0);\r\n\r\n        // Check intake_submissions table (legacy compatibility)\r\n        const intakeSubmissionsCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM intake_submissions\r\n        `).first();\r\n        console.log('Total intake_submissions:', intakeSubmissionsCheck?.count || 0);\r\n\r\n        // Try to get recommendations from the current structure\r\n        const recommendations = await env.DB.prepare(`\r\n          SELECT \r\n            recommendation_id as id,\r\n            created_at as timestamp,\r\n            'recommendation' as type,\r\n            carrier_name as title,\r\n            fit_score as score,\r\n            COUNT(*) as carrier_count,\r\n            AVG(fit_score) as avg_fit\r\n          FROM recommendations\r\n          WHERE user_id = ? AND recommendation_id IS NOT NULL\r\n          GROUP BY recommendation_id\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).bind(userId).all();\r\n\r\n        console.log('Found recommendations:', recommendations.results?.length || 0);\r\n\r\n        // Try to get intakes from the current structure\r\n        const intakes = await env.DB.prepare(`\r\n          SELECT \r\n            id,\r\n            created_at as timestamp,\r\n            'intake' as type,\r\n            'Intake submitted' as title,\r\n            payload_json as intake_data\r\n          FROM intakes\r\n          WHERE user_id = ?\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).bind(userId).all();\r\n\r\n        console.log('Found intakes:', intakes.results?.length || 0);\r\n\r\n        // Also try intake_submissions table as fallback\r\n        const intakeSubmissions = await env.DB.prepare(`\r\n          SELECT \r\n            id,\r\n            created_at as timestamp,\r\n            'intake' as type,\r\n            'Intake submitted' as title,\r\n            data as intake_data\r\n          FROM intake_submissions\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).all();\r\n\r\n        console.log('Found intake_submissions:', intakeSubmissions.results?.length || 0);\r\n\r\n        // Combine and format history\r\n        const history = [];\r\n        \r\n            // Add recommendations\r\n            if (recommendations.results) {\r\n              for (const rec of recommendations.results) {\r\n                history.push({\r\n                  id: rec.id as string,\r\n                  timestamp: rec.timestamp as string,\r\n                  type: rec.type as string,\r\n                  title: `${rec.title as string} - ${Math.round(rec.avg_fit as number)}% fit (${rec.carrier_count as number} carriers)`,\r\n                  score: Math.round(rec.avg_fit as number),\r\n                  intakeData: null\r\n                });\r\n              }\r\n            }\r\n\r\n            // Add intakes\r\n            if (intakes.results) {\r\n              for (const intake of intakes.results) {\r\n                history.push({\r\n                  id: intake.id as string,\r\n                  timestamp: intake.timestamp as string,\r\n                  type: intake.type as string,\r\n                  title: intake.title as string,\r\n                  score: null,\r\n                  intakeData: intake.intake_data ? JSON.parse(intake.intake_data as string) : null\r\n                });\r\n              }\r\n            }\r\n\r\n        // Add intake_submissions as fallback\r\n        if (intakeSubmissions.results && history.length === 0) {\r\n          for (const intake of intakeSubmissions.results) {\r\n            history.push({\r\n              id: intake.id,\r\n              timestamp: intake.timestamp,\r\n              type: intake.type,\r\n              title: intake.title,\r\n              score: null,\r\n              intakeData: intake.intake_data ? JSON.parse(intake.intake_data) : null\r\n            });\r\n          }\r\n        }\r\n\r\n            // Sort by timestamp (newest first)\r\n            history.sort((a: any, b: any) => new Date(b.timestamp as string).getTime() - new Date(a.timestamp as string).getTime());\r\n\r\n        console.log('Returning history with', history.length, 'items');\r\n        console.log('History items:', JSON.stringify(history, null, 2));\r\n        return Response.json(history, { headers: corsHeaders });\r\n      } catch (error) {\r\n        console.error('History endpoint error:', error);\r\n        return Response.json([], { headers: corsHeaders });\r\n      }\r\n    }\r\n    \r\n    if (path === '/api/intake/submit' && request.method === 'POST') {\r\n      try {\r\n        const intake = await request.json();\r\n        const intakeData = intake as any;\r\n        const userId = request.headers.get('X-User-Id') || 'anonymous';\r\n        const recommendationId = 'rec-' + Date.now();\r\n        const intakeId = 'intake-' + Date.now();\r\n        \r\n        // Log the intake for analytics and history tracking\r\n        console.log('Intake submitted:', {\r\n          userId,\r\n          recommendationId,\r\n          intakeId,\r\n          intakeType: intakeData.answers ? 'legacy' : 'orion',\r\n          timestamp: new Date().toISOString()\r\n        });\r\n\r\n        // Store intake in database\r\n        try {\r\n          console.log('Storing intake with userId:', userId, 'intakeId:', intakeId);\r\n          const result = await env.DB.prepare(`\r\n            INSERT INTO intakes (id, tenant_id, payload_json, validated, tier2_triggered, created_at, user_id)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            intakeId, \r\n            'default-tenant', // tenant_id (required field) - use same as existing records\r\n            JSON.stringify(intakeData), // payload_json\r\n            true, // validated\r\n            intakeData.tier2Triggered || false, // tier2_triggered\r\n            new Date().toISOString(), // created_at\r\n            userId // user_id\r\n          ).run();\r\n          console.log('Intake stored successfully:', result);\r\n        } catch (e) {\r\n          console.log('Could not log intake to database:', e);\r\n          console.log('Error details:', e);\r\n        }\r\n\r\n        // Generate real recommendations using AutoRAG\r\n        const recommendations: any[] = [];\r\n        console.log('Generated recommendations:', recommendations.length);\r\n\r\n        // Store recommendations in database\r\n        try {\r\n          console.log('Storing recommendations with userId:', userId, 'intakeId:', intakeId);\r\n          const result = await env.DB.prepare(`\r\n            INSERT INTO recommendations (\r\n              id, intake_id, model_snapshot, fit_json, citations, latency_ms, created_at,\r\n              recommendation_id, user_id, carrier_id, carrier_name, fit_score\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            crypto.randomUUID(),\r\n            intakeId, // intake_id (required)\r\n            'llama-3.1-8b-instruct', // model_snapshot\r\n            JSON.stringify(recommendations), // fit_json (required)\r\n            JSON.stringify(recommendations.flatMap(r => r.citations || [])), // citations (required)\r\n            Date.now() - parseInt(recommendationId.split('-')[1] as string), // latency_ms\r\n            new Date().toISOString(), // created_at\r\n            recommendationId, // recommendation_id\r\n            userId, // user_id\r\n            recommendations[0]?.carrierId || null, // carrier_id (first carrier)\r\n            recommendations[0]?.carrierName || null, // carrier_name (first carrier)\r\n            Math.round(recommendations.reduce((sum, r) => sum + r.fitPct, 0) / recommendations.length) // fit_score (average)\r\n          ).run();\r\n          console.log('Recommendations stored successfully:', result);\r\n        } catch (e: any) {\r\n          console.log('Could not store recommendations:', e);\r\n        }\r\n\r\n        // Calculate summary statistics\r\n        const averageFit = recommendations.length > 0 \r\n          ? Math.round(recommendations.reduce((sum, r) => sum + r.fitPct, 0) / recommendations.length)\r\n          : 0;\r\n\r\n        const topCarrierId = recommendations.length > 0 ? recommendations[0].carrierId : 'none';\r\n\r\n        // Format response in the expected format\r\n        const response = {\r\n          recommendationId,\r\n          status: 'completed',\r\n          intake: intake,\r\n          recommendations: recommendations.map(rec => ({\r\n            carrierId: rec.carrierId,\r\n            carrierName: rec.carrierName,\r\n            fitScore: rec.fitPct,\r\n            tier: rec.fitPct >= 85 ? 'preferred' : rec.fitPct >= 70 ? 'standard' : 'challenging',\r\n            reasoning: {\r\n              pros: rec.reasons,\r\n              cons: rec.advisories,\r\n              summary: `Fit score of ${rec.fitPct}% based on underwriting criteria.`\r\n            },\r\n            estimatedPremium: {\r\n              monthly: Math.round(1200 + (100 - rec.fitPct) * 10),\r\n              annual: Math.round((1200 + (100 - rec.fitPct) * 10) * 12),\r\n              confidence: rec.confidence\r\n            },\r\n            underwritingPath: rec.fitPct >= 80 ? 'simplified' : 'standard',\r\n            requiresExam: rec.apsLikely,\r\n            processingTime: rec.fitPct >= 80 ? '1-2 weeks' : '2-3 weeks',\r\n            citations: rec.citations\r\n          })),\r\n          top: recommendations.slice(0, 1).map(rec => ({\r\n            carrierId: rec.carrierId,\r\n            carrierName: rec.carrierName,\r\n            fitScore: rec.fitPct,\r\n            tier: rec.fitPct >= 85 ? 'preferred' : rec.fitPct >= 70 ? 'standard' : 'challenging',\r\n            reasoning: {\r\n              pros: rec.reasons,\r\n              cons: rec.advisories,\r\n              summary: `Best match with ${rec.fitPct}% fit score.`\r\n            },\r\n            estimatedPremium: {\r\n              monthly: Math.round(1200 + (100 - rec.fitPct) * 10),\r\n              annual: Math.round((1200 + (100 - rec.fitPct) * 10) * 12),\r\n              confidence: rec.confidence\r\n            },\r\n            underwritingPath: rec.fitPct >= 80 ? 'simplified' : 'standard',\r\n            requiresExam: rec.apsLikely,\r\n            processingTime: rec.fitPct >= 80 ? '1-2 weeks' : '2-3 weeks',\r\n            citations: rec.citations\r\n          })),\r\n          premiumSuggestion: `Based on your profile, we recommend starting with a monthly premium of $${Math.round(1200 + (100 - averageFit) * 10)} for optimal coverage.`,\r\n          summary: {\r\n            averageFit,\r\n            totalCarriersEvaluated: recommendations.length,\r\n            tier2Recommended: averageFit < 70,\r\n            topCarrierId,\r\n            notes: recommendations.length > 0 ? 'Real recommendations generated using RAG system.' : 'No carriers found in database.'\r\n          },\r\n          metadata: {\r\n            processingTime: Date.now() - parseInt(recommendationId.split('-')[1]),\r\n            ragQueriesCount: 0, // No manual RAG queries\r\n            citationsFound: recommendations.reduce((sum, r) => sum + r.citations.length, 0),\r\n            modelUsed: 'llama-3.1-8b-instruct'\r\n          },\r\n          timestamp: new Date().toISOString()\r\n        };\r\n\r\n        console.log('Returning response with', recommendations.length, 'recommendations');\r\n        return Response.json(response, { headers: corsHeaders });\r\n\r\n      } catch (error) {\r\n        console.error('Intake submission error:', error);\r\n        return Response.json({\r\n          error: 'Failed to process intake',\r\n          message: (error as Error).message,\r\n          recommendationId: 'error-' + Date.now()\r\n        }, { status: 500, headers: corsHeaders });\r\n      }\r\n    }\r\n    \r\n        // Outcomes endpoint for logging application outcomes\r\n        if (path === '/api/outcomes' && request.method === 'POST') {\r\n          try {\r\n            const outcome = await request.json() as any;\r\n            const userId = request.headers.get('X-User-Id') || 'anonymous';\r\n            \r\n            console.log('Logging outcome:', { userId, outcome });\r\n            \r\n            // Store outcome in database\r\n            try {\r\n              await env.DB.prepare(`\r\n                INSERT INTO outcomes (id, user_id, recommendation_id, carrier_id, status, created_at)\r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n              `).bind(\r\n                crypto.randomUUID(),\r\n                userId,\r\n                outcome.recommendationId || null,\r\n                outcome.carrierId || null,\r\n                outcome.status || 'applied',\r\n                new Date().toISOString()\r\n              ).run();\r\n            } catch (e: any) {\r\n              console.log('Could not log outcome to database:', e);\r\n            }\r\n            \r\n            return Response.json({ success: true, message: 'Outcome logged successfully' }, { headers: corsHeaders });\r\n          } catch (error) {\r\n            console.error('Outcomes endpoint error:', error);\r\n            return Response.json({ error: 'Failed to log outcome' }, { status: 500, headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n        // Recommendations endpoint for retrieving specific recommendations\r\n        if (path.startsWith('/api/recommendations/') && request.method === 'GET') {\r\n          try {\r\n            const recommendationId = path.split('/')[3];\r\n            const userId = request.headers.get('X-User-Id');\r\n            \r\n            console.log('Fetching recommendation:', recommendationId, 'for user:', userId);\r\n            \r\n            // Get recommendation data from database\r\n            const recs = await env.DB.prepare(`\r\n              SELECT * FROM recommendations\r\n              WHERE recommendation_id = ?\r\n                AND user_id = ?\r\n            `).bind(recommendationId, userId).all();\r\n\r\n            if (recs?.results && recs.results.length > 0) {\r\n              // Parse the stored recommendation data\r\n              const storedData = recs.results[0];\r\n              const fitJson = JSON.parse(storedData.fit_json || '[]');\r\n              \r\n              const recommendations = fitJson.map((rec: any) => ({\r\n                carrierId: rec.carrierId,\r\n                carrierName: rec.carrierName,\r\n                fitScore: rec.fitPct,\r\n                tier: rec.fitPct >= 85 ? 'preferred' : rec.fitPct >= 70 ? 'standard' : 'challenging',\r\n                reasoning: {\r\n                  pros: rec.reasons,\r\n                  cons: rec.advisories,\r\n                  summary: `Fit score of ${rec.fitPct}% based on underwriting criteria.`\r\n                },\r\n                estimatedPremium: {\r\n                  monthly: Math.round(1200 + (100 - rec.fitPct) * 10),\r\n                  annual: Math.round((1200 + (100 - rec.fitPct) * 10) * 12),\r\n                  confidence: rec.confidence\r\n                },\r\n                underwritingPath: rec.fitPct >= 80 ? 'simplified' : 'standard',\r\n                requiresExam: rec.apsLikely,\r\n                processingTime: rec.fitPct >= 80 ? '1-2 weeks' : '2-3 weeks',\r\n                citations: rec.citations\r\n              }));\r\n\r\n              const averageFit = recommendations.length > 0 \r\n                ? Math.round(recommendations.reduce((sum: number, r: any) => sum + r.fitScore, 0) / recommendations.length)\r\n                : 0;\r\n\r\n              return Response.json({\r\n                recommendationId,\r\n                status: 'completed',\r\n                recommendations,\r\n                top: recommendations.slice(0, 1),\r\n                premiumSuggestion: `Based on your profile, we recommend starting with a monthly premium of $${Math.round(1200 + (100 - averageFit) * 10)} for optimal coverage.`,\r\n                summary: {\r\n                  averageFit,\r\n                  totalCarriersEvaluated: recommendations.length,\r\n                  tier2Recommended: averageFit < 70,\r\n                  topCarrierId: recommendations[0]?.carrierId || 'none',\r\n                  notes: 'Recommendation retrieved from database.'\r\n                },\r\n                metadata: {\r\n                  processingTime: storedData.latency_ms || 0,\r\n                  citationsFound: recommendations.reduce((sum: number, r: any) => sum + r.citations.length, 0),\r\n                  modelUsed: storedData.model_snapshot || 'llama-3.1-8b-instruct'\r\n                },\r\n                timestamp: storedData.created_at\r\n              }, { headers: corsHeaders });\r\n            } else {\r\n              return Response.json({\r\n                error: 'Recommendation not found',\r\n                recommendationId\r\n              }, { status: 404, headers: corsHeaders });\r\n            }\r\n          } catch (error) {\r\n            console.error('Recommendation retrieval error:', error);\r\n            return Response.json({\r\n              error: 'Failed to retrieve recommendation',\r\n              message: (error as Error).message\r\n            }, { status: 500, headers: corsHeaders });\r\n          }\r\n        }\r\n        \r\n        return Response.json({ error: 'Not found' }, { status: 404, headers: corsHeaders });\r\n      }\r\n    };"],
  "mappings": "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",
  "names": []
}
