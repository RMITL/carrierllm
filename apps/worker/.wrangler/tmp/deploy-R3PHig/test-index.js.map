{
  "version": 3,
  "sources": ["../../../src/ingest.ts", "../../../src/test-index.ts"],
  "sourceRoot": "C:\\sites\\carrierllm\\carrierllm\\apps\\worker\\.wrangler\\tmp\\deploy-R3PHig",
  "sourcesContent": ["// Using Cloudflare's toMarkdown instead of unpdf for better PDF text extraction\r\n\r\n// Define the environment bindings\r\ninterface Env {\r\n  DOCS_BUCKET: R2Bucket;\r\n  CARRIER_INDEX: VectorizeIndex;\r\n  AI: any;\r\n}\r\n\r\n// Function to generate embeddings using Cloudflare AI\r\nasync function generateEmbedding(text: string, env: Env): Promise<number[]> {\r\n  try {\r\n    console.log(`Generating embedding for text of length: ${text.length}`);\r\n    const response = await env.AI.run('@cf/baai/bge-base-en-v1.5', { text: [text] });\r\n    console.log(`Embedding response received, dimensions: ${response.data[0]?.length || 'undefined'}`);\r\n    return response.data[0];\r\n  } catch (error) {\r\n    console.error(`Embedding generation failed: ${error}`);\r\n    console.error(`Error details:`, error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Simple text chunking function\r\nfunction chunkText(text: string, chunkSize = 512, overlap = 50): string[] {\r\n  const chunks: string[] = [];\r\n  let i = 0;\r\n  while (i < text.length) {\r\n    const end = Math.min(i + chunkSize, text.length);\r\n    chunks.push(text.slice(i, end));\r\n    i += chunkSize - overlap;\r\n  }\r\n  return chunks;\r\n}\r\n\r\n// Main ingestion logic\r\nexport async function runIngestion(env: Env): Promise<Response> {\r\n  console.log('Ingestion function triggered successfully.');\r\n  try {\r\n    console.log('Starting ingestion process...');\r\n\r\n    // 1. List all PDFs in the R2 bucket\r\n    const list = await env.DOCS_BUCKET.list();\r\n    const pdfFiles = list.objects.filter(obj => obj.key.toLowerCase().endsWith('.pdf'));\r\n\r\n    if (pdfFiles.length === 0) {\r\n      console.log('No PDF files found in the bucket.');\r\n      return new Response('No PDF files found to ingest.', { status: 404 });\r\n    }\r\n\r\n    console.log(`Found ${pdfFiles.length} PDF files to process.`);\r\n    let totalVectorsInserted = 0;\r\n\r\n        // 2. Process each PDF file sequentially to avoid resource limits\r\n        for (let i = 0; i < Math.min(pdfFiles.length, 5); i++) { // Limit to first 5 files for testing\r\n          const pdfFile = pdfFiles[i];\r\n          console.log(`Processing file ${i + 1}/${Math.min(pdfFiles.length, 5)}: ${pdfFile.key}`);\r\n\r\n          try {\r\n            const object = await env.DOCS_BUCKET.get(pdfFile.key);\r\n            if (object === null) {\r\n              console.log(`Could not retrieve file: ${pdfFile.key}`);\r\n              continue;\r\n            }\r\n\r\n            const pdfBuffer = await object.arrayBuffer();\r\n            \r\n            // Extract text from PDF using Cloudflare's toMarkdown\r\n            let text = '';\r\n            try {\r\n              console.log(`Starting text extraction for ${pdfFile.key}...`);\r\n              console.log(`PDF buffer size: ${pdfBuffer.byteLength} bytes`);\r\n              \r\n              // Use Cloudflare's toMarkdown for PDF text extraction\r\n              const result = await env.AI.toMarkdown([\r\n                {\r\n                  name: pdfFile.key,\r\n                  blob: new Blob([pdfBuffer], {\r\n                    type: \"application/pdf\",\r\n                  }),\r\n                },\r\n              ]);\r\n              \r\n              console.log(`toMarkdown result type: ${typeof result}`);\r\n              console.log(`toMarkdown result length: ${Array.isArray(result) ? result.length : 'not array'}`);\r\n              if (Array.isArray(result) && result.length > 0) {\r\n                console.log(`First item type: ${typeof result[0]}`);\r\n                console.log(`First item keys: ${Object.keys(result[0] || {}).join(', ')}`);\r\n                console.log(`First item sample:`, JSON.stringify(result[0]).substring(0, 500));\r\n              }\r\n              \r\n              // Handle different return types from toMarkdown\r\n              if (typeof result === 'string') {\r\n                text = result;\r\n              } else if (Array.isArray(result) && result.length > 0) {\r\n                // toMarkdown returns an array of objects with data property containing markdown text\r\n                text = result.map(item => {\r\n                  if (typeof item === 'string') return item;\r\n                  if (item && typeof item === 'object') {\r\n                    return item.data || item.text || item.content || String(item);\r\n                  }\r\n                  return String(item);\r\n                }).join('\\n');\r\n              } else if (result && typeof result === 'object') {\r\n                // If it's an object, try to extract text from it\r\n                if (result.text) {\r\n                  text = result.text;\r\n                } else if (result.content) {\r\n                  text = result.content;\r\n                } else {\r\n                  text = String(result);\r\n                }\r\n              } else {\r\n                text = String(result || '');\r\n              }\r\n              \r\n              console.log(`Final text length: ${text.length} characters from ${pdfFile.key}`);\r\n              console.log(`First 200 chars of extracted text: ${text.substring(0, 200)}`);\r\n              \r\n              if (text.length === 0) {\r\n                console.warn(`No text extracted from ${pdfFile.key}, using fallback`);\r\n                const carrierName = pdfFile.key.split('-')[0].split('_').join(' ').toLowerCase();\r\n                text = `${carrierName.toUpperCase()} UNDERWRITING GUIDELINES - PDF parsing returned empty text, using filename-based content`;\r\n              }\r\n            } catch (error) {\r\n              console.error(`Failed to parse PDF ${pdfFile.key}:`, error);\r\n              console.error(`Error details:`, error.message);\r\n              // Fallback: create basic text based on filename\r\n              const carrierName = pdfFile.key.split('-')[0].split('_').join(' ').toLowerCase();\r\n              text = `${carrierName.toUpperCase()} UNDERWRITING GUIDELINES - PDF parsing failed, using filename-based content`;\r\n            }\r\n\r\n            // 3. Chunk the text content\r\n            const chunks = chunkText(text);\r\n            console.log(`File ${pdfFile.key} was split into ${chunks.length} chunks.`);\r\n\r\n            // Extract carrier name from filename\r\n            const carrierId = pdfFile.key.split('-')[0].split('_').join(' ').toLowerCase();\r\n\r\n            // 4. Generate embeddings and prepare for insertion\r\n            const vectors: VectorizeVector[] = [];\r\n            for (let j = 0; j < Math.min(chunks.length, 10); j++) { // Limit chunks per file\r\n              const chunk = chunks[j];\r\n              const embedding = await generateEmbedding(chunk, env);\r\n\r\n              if (embedding.length > 0) {\r\n                // Create shorter ID to avoid 64-byte limit\r\n                const shortId = `${pdfFile.key.replace('.pdf', '')}-${j}`.substring(0, 64);\r\n                vectors.push({\r\n                  id: shortId,\r\n                  values: embedding,\r\n                  metadata: {\r\n                    carrierId: carrierId,\r\n                    source: pdfFile.key,\r\n                    text: chunk,\r\n                  },\r\n                });\r\n              }\r\n            }\r\n\r\n            // 5. Insert vectors into the Vectorize index\r\n            if (vectors.length > 0) {\r\n              await env.CARRIER_INDEX.upsert(vectors);\r\n              console.log(`Inserted ${vectors.length} vectors for ${pdfFile.key}.`);\r\n              totalVectorsInserted += vectors.length;\r\n            }\r\n\r\n            // Add a small delay to prevent overwhelming the system\r\n            await new Promise(resolve => setTimeout(resolve, 1000));\r\n            \r\n          } catch (error) {\r\n            console.error(`Error processing file ${pdfFile.key}:`, error);\r\n            continue;\r\n          }\r\n        }\r\n\r\n    console.log(`Ingestion complete. Total vectors inserted: ${totalVectorsInserted}`);\r\n    return new Response(JSON.stringify({\r\n      success: true,\r\n      message: `Ingestion complete. Processed ${pdfFiles.length} files and inserted ${totalVectorsInserted} vectors.`,\r\n    }), { headers: { 'Content-Type': 'application/json' } });\r\n\r\n  } catch (error) {\r\n    console.error('Ingestion process failed:', error);\r\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';\r\n    return new Response(JSON.stringify({ success: false, error: errorMessage }), {\r\n      status: 500,\r\n      headers: { 'Content-Type': 'application/json' },\r\n    });\r\n  }\r\n}\r\n", "import { runIngestion } from './ingest';\r\n\r\n// Simple test worker with all required endpoints\r\ninterface Env {\r\n  DB: D1Database;\r\n  DOCS_BUCKET: R2Bucket;\r\n  CARRIER_INDEX: VectorizeIndex;\r\n  AI: any;\r\n  CLERK_SECRET_KEY?: string;\r\n}\r\n\r\n// Helper function to generate embeddings\r\nasync function generateEmbedding(text: string, env: Env): Promise<number[]> {\r\n  try {\r\n    console.log(`Generating embedding for text of length: ${text.length}`);\r\n    const response = await env.AI.run('@cf/baai/bge-base-en-v1.5', { text: [text] });\r\n    console.log(`Embedding response received, dimensions: ${response.data[0]?.length || 'undefined'}`);\r\n    return response.data[0];\r\n  } catch (error) {\r\n    console.error('Embedding generation failed:', error);\r\n    console.error('Error details:', error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Helper function to perform RAG search\r\nasync function performRAGSearch(query: string, env: Env, topK = 15): Promise<any[]> {\r\n  try {\r\n    console.log('RAG: Starting search for query:', query);\r\n    const queryEmbedding = await generateEmbedding(query, env);\r\n    console.log('RAG: Generated embedding length:', queryEmbedding.length);\r\n    \r\n    if (queryEmbedding.length === 0) {\r\n      console.log('RAG: Embedding generation failed, returning empty results');\r\n      return [];\r\n    }\r\n    \r\n    console.log('RAG: About to query Vectorize with embedding of length:', queryEmbedding.length);\r\n    console.log('RAG: Embedding type:', typeof queryEmbedding);\r\n    console.log('RAG: Is array:', Array.isArray(queryEmbedding));\r\n    \r\n    const results = await env.CARRIER_INDEX.query(queryEmbedding, {\r\n      topK,\r\n      returnMetadata: true,\r\n    });\r\n    \r\n    console.log('RAG: Query successful, found', results.matches?.length || 0, 'matches');\r\n    return results.matches.map(match => match.metadata);\r\n  } catch (error) {\r\n    console.error('RAG search failed:', error);\r\n    console.error('RAG error details:', error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Enhanced PCG-based recommendation logic with AI analysis\r\nasync function generateRealRecommendations(intakeData: any, env: Env): Promise<any[]> {\r\n    try {\r\n        console.log('Starting generateRealRecommendations with intake data:', intakeData);\r\n        \r\n        // Create a more comprehensive client profile query\r\n        const coverageAmount = intakeData.core?.coverageTarget?.amount || intakeData.coverage_amount || 500000;\r\n        const clientProfileQuery = `\r\n          Client Profile:\r\n          - Age: ${intakeData.core?.age || intakeData.age || 35}\r\n          - Gender: ${intakeData.core?.gender || intakeData.gender || 'Male'}\r\n          - Health Status: ${intakeData.core?.health || intakeData.health || 'Excellent'}\r\n          - Occupation: ${intakeData.core?.occupation || intakeData.occupation || 'Professional'}\r\n          - Nicotine Use: ${intakeData.core?.nicotine?.lastUse || (intakeData.smoker ? 'current' : 'never')}\r\n          - Health Conditions: ${intakeData.core?.majorConditions || intakeData.family_history || 'none'}\r\n          - Coverage Amount: $${coverageAmount.toLocaleString()}\r\n          - Coverage Type: ${intakeData.core?.coverageTarget?.type || intakeData.coverage_type || 'term'}\r\n          - Term Length: ${intakeData.core?.termLength || intakeData.term_length || 20} years\r\n          - Income: $${(intakeData.core?.income || intakeData.income || 100000).toLocaleString()}\r\n        `;\r\n        \r\n        console.log('Generated client profile query:', clientProfileQuery);\r\n        \r\n        const ragResults = await performRAGSearch(clientProfileQuery, env);\r\n        console.log('RAG search completed, found', ragResults.length, 'results');\r\n        \r\n        if (ragResults.length === 0) {\r\n            console.log('No RAG results found, returning empty recommendations');\r\n            return [];\r\n        }\r\n        \r\n        // Group results by carrier and analyze with AI\r\n        const carrierGroups = new Map();\r\n        ragResults.forEach((result: any) => {\r\n            const carrierId = result.carrierId || 'unknown';\r\n            if (!carrierGroups.has(carrierId)) {\r\n                carrierGroups.set(carrierId, []);\r\n            }\r\n            carrierGroups.get(carrierId).push(result);\r\n        });\r\n        \r\n        console.log('Grouped results by carrier:', carrierGroups.size, 'carriers');\r\n        \r\n        // Generate AI-powered recommendations for each carrier\r\n        const recommendations = [];\r\n        for (const [carrierId, results] of carrierGroups) {\r\n            try {\r\n                const recommendation = await generateCarrierRecommendation(carrierId, results, clientProfileQuery, env);\r\n                if (recommendation) {\r\n                    recommendations.push(recommendation);\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error generating recommendation for ${carrierId}:`, error);\r\n            }\r\n        }\r\n        \r\n        // Sort by fit score (highest first)\r\n        recommendations.sort((a, b) => (b.fitPct || 0) - (a.fitPct || 0));\r\n        \r\n        console.log('Generated', recommendations.length, 'recommendations');\r\n        return recommendations.slice(0, 10); // Return top 10\r\n    } catch (error) {\r\n        console.error('Error in generateRealRecommendations:', error);\r\n        console.error('Error details:', error.message);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Generate AI-powered recommendation for a specific carrier\r\nasync function generateCarrierRecommendation(carrierId: string, results: any[], clientProfile: string, env: Env): Promise<any> {\r\n    try {\r\n        // Combine all text from this carrier's results\r\n        const combinedText = results.map(r => r.text).join('\\n\\n');\r\n        const topResult = results[0]; // Use the highest scoring result\r\n        \r\n        // Create AI prompt for PCG analysis\r\n        const aiPrompt = `\r\n        You are an insurance underwriting expert. Analyze the carrier's underwriting guidelines for the given client profile and provide a PCG (Preferential Carrier Grade) assessment.\r\n\r\n        CLIENT PROFILE:\r\n        ${clientProfile}\r\n\r\n        CARRIER: ${carrierId}\r\n        UNDERWRITING GUIDELINES:\r\n        ${combinedText.substring(0, 2000)}\r\n\r\n        IMPORTANT: Respond ONLY with valid JSON in this exact format:\r\n        {\r\n          \"fitPct\": 85,\r\n          \"reasons\": [\"Age is within preferred range\", \"No nicotine use\", \"Excellent health\"],\r\n          \"advisories\": [\"High income may require additional documentation\"],\r\n          \"confidence\": 90,\r\n          \"product\": \"Life Insurance\",\r\n          \"underwritingPath\": \"standard\",\r\n          \"citations\": [{\"source\": \"Carrier Guidelines\", \"text\": \"Relevant excerpt from guidelines\"}]\r\n        }\r\n\r\n        Analysis criteria:\r\n        - fitPct: 0-100 based on how well client matches carrier guidelines\r\n        - reasons: 3-5 specific positive factors\r\n        - advisories: 0-3 potential concerns or requirements\r\n        - confidence: 0-100 based on data quality\r\n        - product: \"Life Insurance\", \"Term Life\", \"IUL\", etc.\r\n        - underwritingPath: \"simplified\", \"standard\", or \"complex\"\r\n        - citations: 1-3 relevant excerpts from guidelines\r\n\r\n        Respond with ONLY the JSON object, no other text.`;\r\n\r\n        console.log(`Generating AI analysis for ${carrierId}...`);\r\n        \r\n        const aiResponse = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {\r\n            messages: [\r\n                {\r\n                    role: 'user',\r\n                    content: aiPrompt\r\n                }\r\n            ],\r\n            max_tokens: 1000\r\n        });\r\n\r\n        let analysis;\r\n        try {\r\n            // Try to parse the AI response as JSON\r\n            const responseText = aiResponse.response || aiResponse.choices?.[0]?.message?.content || '';\r\n            console.log(`AI response for ${carrierId}:`, responseText.substring(0, 200));\r\n            \r\n            // Try multiple JSON extraction methods\r\n            let jsonText = '';\r\n            \r\n            // Method 1: Look for JSON object (more robust)\r\n            const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n            if (jsonMatch) {\r\n                jsonText = jsonMatch[0];\r\n                // Try to clean up common JSON issues\r\n                jsonText = jsonText\r\n                    .replace(/,\\s*}/g, '}')  // Remove trailing commas\r\n                    .replace(/,\\s*]/g, ']')  // Remove trailing commas in arrays\r\n                    .replace(/(\\w+):/g, '\"$1\":')  // Quote unquoted keys\r\n                    .replace(/:(\\w+)/g, ':\"$1\"')  // Quote unquoted string values\r\n                    .replace(/:(\\d+\\.?\\d*)/g, ':$1');  // Keep numbers unquoted\r\n            } else {\r\n                // Method 2: Look for fitPct in the text\r\n                const fitPctMatch = responseText.match(/fitPct[\"\\s]*:[\\s]*(\\d+)/i);\r\n                const reasonsMatch = responseText.match(/reasons[\"\\s]*:[\\s]*\\[(.*?)\\]/i);\r\n                const advisoriesMatch = responseText.match(/advisories[\"\\s]*:[\\s]*\\[(.*?)\\]/i);\r\n                \r\n                if (fitPctMatch) {\r\n                    const fitPct = parseInt(fitPctMatch[1]);\r\n                    const reasons = reasonsMatch ? reasonsMatch[1].split(',').map(r => r.trim().replace(/['\"]/g, '')) : [`${carrierId} underwriting guidelines applicable`];\r\n                    const advisories = advisoriesMatch ? advisoriesMatch[1].split(',').map(a => a.trim().replace(/['\"]/g, '')) : [];\r\n                    \r\n                    analysis = {\r\n                        fitPct: fitPct,\r\n                        reasons: reasons,\r\n                        advisories: advisories,\r\n                        confidence: 80,\r\n                        product: 'Life Insurance',\r\n                        underwritingPath: 'standard'\r\n                    };\r\n                } else {\r\n                    throw new Error('No structured data found in AI response');\r\n                }\r\n            }\r\n            \r\n            if (jsonText && !analysis) {\r\n                analysis = JSON.parse(jsonText);\r\n            }\r\n        } catch (parseError) {\r\n            console.error(`Failed to parse AI response for ${carrierId}:`, parseError);\r\n            // Fallback to basic analysis based on RAG score\r\n            const baseScore = Math.round((topResult.score || 0.5) * 100);\r\n            analysis = {\r\n                fitPct: Math.max(60, baseScore), // Ensure minimum 60% for successful RAG matches\r\n                reasons: [`${formatCarrierName(carrierId)} underwriting guidelines match client profile`],\r\n                advisories: [],\r\n                confidence: 70,\r\n                product: 'Life Insurance',\r\n                underwritingPath: 'standard'\r\n            };\r\n        }\r\n\r\n        return {\r\n            carrierId: carrierId,\r\n            carrierName: formatCarrierName(carrierId),\r\n            fitScore: Math.max(0, Math.min(100, analysis.fitPct || 0)),\r\n            reasoning: {\r\n                pros: analysis.reasons || [`${carrierId} guidelines applicable`],\r\n                cons: analysis.advisories || [],\r\n                summary: `Fit score of ${Math.max(0, Math.min(100, analysis.fitPct || 0))}% based on underwriting criteria.`\r\n            },\r\n            estimatedPremium: {\r\n                monthly: Math.round(1200 + (100 - (analysis.fitPct || 0)) * 10),\r\n                annual: Math.round((1200 + (100 - (analysis.fitPct || 0)) * 10) * 12)\r\n            },\r\n            confidence: analysis.confidence >= 80 ? 'high' : analysis.confidence >= 60 ? 'medium' : 'low',\r\n            citations: (analysis.citations || [{ source: topResult.source, text: topResult.text.substring(0, 200) }]).map((citation: any, index: number) => ({\r\n                chunkId: `${carrierId}-${index}`,\r\n                snippet: citation.text || citation.snippet || '',\r\n                documentTitle: citation.source || 'Carrier Underwriting Guide',\r\n                effectiveDate: new Date().toISOString(),\r\n                score: topResult.score || 0.8\r\n            }))\r\n        };\r\n    } catch (error) {\r\n        console.error(`Error in generateCarrierRecommendation for ${carrierId}:`, error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Format carrier names for display\r\nfunction formatCarrierName(carrierId: string): string {\r\n    return carrierId\r\n        .split('-')\r\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\r\n        .join(' ');\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    \r\n    // CORS headers\r\n    const corsHeaders = {\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-User-Id',\r\n      'Content-Type': 'application/json'\r\n    };\r\n\r\n    // Handle CORS preflight\r\n    if (request.method === 'OPTIONS') {\r\n      return new Response(null, { status: 204, headers: corsHeaders });\r\n    }\r\n    \r\n        // Ingestion endpoint (protected)\r\n        if (path === '/api/ingest-docs' && request.method === 'POST') {\r\n          const secret = request.headers.get('X-Admin-Secret');\r\n          if (secret !== 'your-super-secret-key') { // Use a secret from env vars in production\r\n            return new Response('Unauthorized', { status: 401 });\r\n          }\r\n          console.log('Ingestion endpoint called - starting process...');\r\n          try {\r\n            const result = await runIngestion(env);\r\n            console.log('Ingestion process completed');\r\n            return result;\r\n          } catch (error) {\r\n            console.error('Ingestion process failed:', error);\r\n            return Response.json({ success: false, error: error.message }, { status: 500 });\r\n          }\r\n        }\r\n    \r\n        if (path === '/api/health') {\r\n          return Response.json({ status: 'healthy', timestamp: new Date().toISOString() }, { headers: corsHeaders });\r\n        }\r\n\r\n        // Clear history endpoint\r\n        if (path.startsWith('/api/user/') && path.endsWith('/history') && request.method === 'DELETE') {\r\n          try {\r\n            const userId = path.split('/')[3];\r\n            console.log('Clearing history for user:', userId);\r\n            \r\n            // Delete from all relevant tables\r\n            await env.DB.prepare(`\r\n              DELETE FROM recommendations WHERE user_id = ?\r\n            `).bind(userId).run();\r\n            \r\n            await env.DB.prepare(`\r\n              DELETE FROM intakes WHERE user_id = ?\r\n            `).bind(userId).run();\r\n            \r\n            await env.DB.prepare(`\r\n              DELETE FROM intake_submissions WHERE user_id = ?\r\n            `).bind(userId).run();\r\n            \r\n            console.log('History cleared successfully for user:', userId);\r\n            return Response.json({ success: true, message: 'History cleared successfully' }, { headers: corsHeaders });\r\n          } catch (error) {\r\n            console.error('Error clearing history:', error);\r\n            return Response.json({ error: 'Failed to clear history' }, { status: 500, headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n        // Test endpoint to check database insert\r\n        if (path === '/api/test-db' && request.method === 'POST') {\r\n          try {\r\n            const userId = request.headers.get('X-User-Id') || 'test-user';\r\n            const testId = 'test-' + Date.now();\r\n            \r\n            console.log('Testing database insert with userId:', userId);\r\n            \r\n            const result = await env.DB.prepare(`\r\n              INSERT INTO intakes (id, tenant_id, payload_json, validated, tier2_triggered, created_at, user_id)\r\n              VALUES (?, ?, ?, ?, ?, ?, ?)\r\n            `).bind(\r\n              testId,\r\n              'default-tenant',\r\n              '{\"test\": true}',\r\n              true,\r\n              false,\r\n              new Date().toISOString(),\r\n              userId\r\n            ).run();\r\n            \r\n            console.log('Test insert result:', result);\r\n            \r\n            return Response.json({ \r\n              success: true, \r\n              result: result,\r\n              userId: userId,\r\n              testId: testId\r\n            }, { headers: corsHeaders });\r\n          } catch (e: any) {\r\n            console.log('Test insert failed:', e);\r\n            return Response.json({ \r\n              success: false, \r\n              error: e.message,\r\n              userId: request.headers.get('X-User-Id') || 'test-user'\r\n            }, { headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n        // Debug endpoint to check Vectorize index status\r\n        if (path === '/api/debug-vectorize' && request.method === 'GET') {\r\n          try {\r\n            // Generate a proper embedding for testing\r\n            const testText = 'insurance underwriting guidelines';\r\n            console.log('Debug: Generating test embedding for:', testText);\r\n            const testEmbeddingVector = await generateEmbedding(testText, env);\r\n            console.log('Debug: Generated embedding length:', testEmbeddingVector.length);\r\n            \r\n            if (testEmbeddingVector.length === 0) {\r\n              return Response.json({\r\n                success: false,\r\n                error: 'Failed to generate test embedding - returned empty array'\r\n              }, { headers: corsHeaders });\r\n            }\r\n\r\n            // Try a simple search to see if the index has any data\r\n            console.log('Debug: About to query Vectorize with embedding of length:', testEmbeddingVector.length);\r\n            console.log('Debug: First few values of embedding:', testEmbeddingVector.slice(0, 5));\r\n            console.log('Debug: Embedding type:', typeof testEmbeddingVector);\r\n            console.log('Debug: Is array:', Array.isArray(testEmbeddingVector));\r\n            console.log('Debug: Embedding constructor:', testEmbeddingVector.constructor.name);\r\n            \r\n            // Try to get index info first\r\n            try {\r\n              const indexInfo = await env.CARRIER_INDEX.describe();\r\n              console.log('Debug: Index info:', indexInfo);\r\n            } catch (e) {\r\n              console.log('Debug: Could not get index info:', e.message);\r\n            }\r\n            \r\n            // Try different query formats to see which one works\r\n            let testEmbedding;\r\n            try {\r\n              // Try the object format first\r\n              console.log('Debug: Trying object format query...');\r\n              testEmbedding = await env.CARRIER_INDEX.query({\r\n                vector: testEmbeddingVector,\r\n                topK: 5,\r\n                returnMetadata: true\r\n              });\r\n              console.log('Debug: Object format query succeeded');\r\n            } catch (e1) {\r\n              console.log('Debug: Object format failed:', e1.message);\r\n              try {\r\n                // Try the array format\r\n                console.log('Debug: Trying array format query...');\r\n                testEmbedding = await env.CARRIER_INDEX.query(testEmbeddingVector, {\r\n                  topK: 5,\r\n                  returnMetadata: true\r\n                });\r\n                console.log('Debug: Array format query succeeded');\r\n              } catch (e2) {\r\n                console.log('Debug: Array format failed:', e2.message);\r\n                throw e2;\r\n              }\r\n            }\r\n\r\n            return Response.json({\r\n              success: true,\r\n              indexStatus: 'accessible',\r\n              totalMatches: testEmbedding.matches?.length || 0,\r\n              sampleMatches: testEmbedding.matches?.slice(0, 2) || [],\r\n              embeddingLength: testEmbeddingVector.length,\r\n              testText: testText\r\n            }, { headers: corsHeaders });\r\n          } catch (e: any) {\r\n            console.log('Vectorize debug failed:', e);\r\n            return Response.json({\r\n              success: false,\r\n              error: e.message,\r\n              stack: e.stack\r\n            }, { headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n    // Analytics endpoint\r\n    if (path === '/api/analytics/summary') {\r\n      try {\r\n        const userId = request.headers.get('X-User-Id');\r\n\r\n        // Get current month for date filtering\r\n        const now = new Date();\r\n        const currentMonth = now.toISOString().slice(0, 7); // YYYY-MM format\r\n        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\r\n\r\n        // Initialize response data with real zeros\r\n        let stats = {\r\n          totalIntakes: 0,\r\n          averageFitScore: 0,\r\n          placementRate: 0,\r\n          remainingRecommendations: 5 // Default free tier limit\r\n        };\r\n\r\n        let topCarriers: any[] = [];\r\n        let trends: any[] = [];\r\n\r\n        try {\r\n          // Get user-specific intakes if userId provided, otherwise system-wide\r\n          if (userId) {\r\n            const userIntakesResult = await env.DB.prepare(`\r\n              SELECT COUNT(*) as count FROM intakes WHERE user_id = ?\r\n            `).bind(userId).first();\r\n            stats.totalIntakes = (userIntakesResult?.count as number) || 0;\r\n          } else {\r\n            // System-wide total for admin view\r\n            const intakesResult = await env.DB.prepare(`\r\n              SELECT COUNT(*) as count FROM intakes\r\n            `).first();\r\n            stats.totalIntakes = (intakesResult?.count as number) || 0;\r\n          }\r\n\r\n          // If we have a user ID, get user-specific data\r\n          if (userId) {\r\n            // Get user's monthly usage\r\n            try {\r\n              const userUsage = await env.DB.prepare(`\r\n                SELECT COUNT(*) as used\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                  AND created_at >= ?\r\n              `).bind(userId, monthStart).first();\r\n\r\n              const used = (userUsage?.used as number) || 0;\r\n              \r\n              // Get plan limits from Clerk API\r\n              let planLimit = 5; // Default free tier\r\n              try {\r\n                const clerkApiKey = env.CLERK_SECRET_KEY;\r\n                if (clerkApiKey) {\r\n                  const clerkResponse = await fetch(`https://api.clerk.com/v1/users/${userId}`, {\r\n                    headers: {\r\n                      'Authorization': `Bearer ${clerkApiKey}`,\r\n                      'Content-Type': 'application/json'\r\n                    }\r\n                  });\r\n                  \r\n                  if (clerkResponse.ok) {\r\n                    const userData = await clerkResponse.json();\r\n                    const publicMetadata = userData.public_metadata || {};\r\n                    \r\n                    if (publicMetadata.plan_slug) {\r\n                      if (publicMetadata.plan_slug === 'enterprise') {\r\n                        planLimit = -1; // Unlimited\r\n                      } else if (publicMetadata.plan_slug === 'individual') {\r\n                        planLimit = 100;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              } catch (e) {\r\n                console.log('Could not get plan limits from Clerk:', e);\r\n              }\r\n              \r\n              stats.remainingRecommendations = planLimit === -1 ? 999 : Math.max(0, planLimit - used);\r\n        } catch (e: any) {\r\n          console.log('Could not get user usage:', e);\r\n        }\r\n\r\n            // Get user's average fit score\r\n            try {\r\n              const avgScore = await env.DB.prepare(`\r\n                SELECT AVG(fit_score) as avg\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n              `).bind(userId).first();\r\n\r\n              if (avgScore?.avg && avgScore.avg > 0) {\r\n                stats.averageFitScore = Math.round(avgScore.avg as number);\r\n              }\r\n              // If no real data, keep it at 0\r\n            } catch (e) {\r\n              console.log('Could not get average score:', e);\r\n            }\r\n\r\n            // Get top carriers\r\n            try {\r\n              const carriers = await env.DB.prepare(`\r\n                SELECT\r\n                  carrier_id,\r\n                  carrier_name,\r\n                  COUNT(*) as count,\r\n                  AVG(fit_score) as avg_score\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                GROUP BY carrier_id, carrier_name\r\n                ORDER BY count DESC\r\n                LIMIT 5\r\n              `).bind(userId).all();\r\n\r\n              if (carriers?.results) {\r\n                topCarriers = carriers.results.map((c: any, idx: number) => ({\r\n                  id: c.carrier_id || String(idx + 1),\r\n                  name: c.carrier_name || `Carrier ${idx + 1}`,\r\n                  count: c.count || 0,\r\n                  successRate: Math.round(c.avg_score || 0) // Use 0 instead of 75\r\n                }));\r\n              }\r\n            } catch (e) {\r\n              console.log('Could not get top carriers:', e);\r\n            }\r\n\r\n            // Get monthly trends (last 6 months)\r\n            try {\r\n              const sixMonthsAgo = new Date();\r\n              sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n\r\n              const monthlyData = await env.DB.prepare(`\r\n                SELECT\r\n                  strftime('%Y-%m', created_at) as month,\r\n                  COUNT(*) as count\r\n                FROM recommendations\r\n                WHERE user_id = ?\r\n                  AND created_at >= ?\r\n                GROUP BY strftime('%Y-%m', created_at)\r\n                ORDER BY month DESC\r\n                LIMIT 6\r\n              `).bind(userId, sixMonthsAgo.toISOString()).all();\r\n\r\n              if (monthlyData?.results) {\r\n                trends = monthlyData.results.map((m: any) => ({\r\n                  month: m.month,\r\n                  intakes: m.count || 0,\r\n                  conversions: 0, // No real conversion data yet\r\n                  conversionRate: 0 // No real conversion rate yet\r\n                }));\r\n              }\r\n            } catch (e) {\r\n              console.log('Could not get trends:', e);\r\n            }\r\n          }\r\n\r\n          // Calculate placement rate - user-specific if userId provided\r\n          try {\r\n            let placements;\r\n            if (userId) {\r\n              // User-specific placement rate\r\n              placements = await env.DB.prepare(`\r\n                SELECT\r\n                  COUNT(CASE WHEN status = 'approved' OR status = 'placed' THEN 1 END) as placed,\r\n                  COUNT(*) as total\r\n                FROM outcomes\r\n                WHERE user_id = ?\r\n              `).bind(userId).first();\r\n            } else {\r\n              // System-wide placement rate\r\n              placements = await env.DB.prepare(`\r\n                SELECT\r\n                  COUNT(CASE WHEN status = 'approved' OR status = 'placed' THEN 1 END) as placed,\r\n                  COUNT(*) as total\r\n                FROM outcomes\r\n              `).first();\r\n            }\r\n\r\n            if (placements && (placements.total as number) > 0) {\r\n              stats.placementRate = Math.round(((placements.placed as number) / (placements.total as number)) * 100);\r\n            }\r\n            // If no outcomes data, keep placement rate at 0\r\n          } catch (e) {\r\n            console.log('Could not get placement rate:', e);\r\n            // Keep placement rate at 0 if no data\r\n          }\r\n\r\n        } catch (dbError) {\r\n          console.error('Database query error:', dbError);\r\n          // Continue with default values if DB queries fail\r\n        }\r\n\r\n        // Return real data only - no mock data\r\n        return Response.json({\r\n          stats,\r\n          topCarriers,\r\n          trends,\r\n          lastUpdated: new Date().toISOString(),\r\n          context: {\r\n            userId: userId || null,\r\n            scope: userId ? 'user-specific' : 'system-wide',\r\n            planInfo: userId ? 'User plan data from Clerk API' : 'System-wide analytics'\r\n          }\r\n        }, { headers: corsHeaders });\r\n\r\n      } catch (error) {\r\n        console.error('Analytics endpoint error:', error);\r\n        return Response.json({\r\n          stats: {\r\n            totalIntakes: 0,\r\n            averageFitScore: 0,\r\n            placementRate: 0,\r\n            remainingRecommendations: 5 // Default free tier limit\r\n          },\r\n          topCarriers: [],\r\n          trends: [],\r\n          lastUpdated: new Date().toISOString(),\r\n          error: 'Analytics data temporarily unavailable'\r\n        }, { status: 200, headers: corsHeaders });\r\n      }\r\n    }\r\n\r\n    // Subscription endpoint for billing\r\n    if (path.startsWith('/api/subscriptions/') && request.method === 'GET') {\r\n      const userId = path.split('/')[3];\r\n      try {\r\n        console.log('Fetching subscription data for user:', userId);\r\n        \r\n        // Get current month for usage calculation\r\n        const now = new Date();\r\n        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\r\n        \r\n        // Get user's current usage from recommendations table\r\n        let currentUsage = 0;\r\n        try {\r\n          const usageResult = await env.DB.prepare(`\r\n            SELECT COUNT(*) as count\r\n            FROM recommendations\r\n            WHERE user_id = ?\r\n              AND created_at >= ?\r\n          `).bind(userId, monthStart).first();\r\n          \r\n          currentUsage = (usageResult?.count as number) || 0;\r\n          console.log('User current usage:', currentUsage);\r\n        } catch (e: any) {\r\n          console.log('Could not get user usage:', e);\r\n        }\r\n        \r\n        // Get plan information from Clerk's API\r\n        let planLimit = 5; // Default free tier\r\n        let planName = 'Free';\r\n        let planSlug = 'free';\r\n        \r\n        try {\r\n          // Call Clerk's API to get user subscription data\r\n          const clerkApiKey = env.CLERK_SECRET_KEY;\r\n          if (clerkApiKey) {\r\n            const clerkResponse = await fetch(`https://api.clerk.com/v1/users/${userId}`, {\r\n              headers: {\r\n                'Authorization': `Bearer ${clerkApiKey}`,\r\n                'Content-Type': 'application/json'\r\n              }\r\n            });\r\n            \r\n            if (clerkResponse.ok) {\r\n              const userData = await clerkResponse.json();\r\n              const publicMetadata = userData.public_metadata || {};\r\n              \r\n              // Extract plan information from Clerk's publicMetadata\r\n              if (publicMetadata.plan_name || publicMetadata.plan_slug) {\r\n                planName = publicMetadata.plan_name || 'Individual';\r\n                planSlug = publicMetadata.plan_slug || 'individual';\r\n                \r\n                // Set limits based on plan\r\n                if (planSlug === 'enterprise') {\r\n                  planLimit = -1; // Unlimited\r\n                } else if (planSlug === 'individual') {\r\n                  planLimit = 100;\r\n                } else {\r\n                  planLimit = 5; // Free tier\r\n                }\r\n                \r\n                console.log('Found Clerk plan data:', { planName, planSlug, planLimit });\r\n              }\r\n            } else {\r\n              console.log('Could not fetch user data from Clerk:', clerkResponse.status);\r\n            }\r\n          } else {\r\n            console.log('No Clerk API key available');\r\n          }\r\n        } catch (e) {\r\n          console.log('Could not get plan from Clerk API:', e);\r\n          // Keep default free plan\r\n        }\r\n        \r\n        return Response.json({\r\n          userId,\r\n          subscription: null, // No subscription until user actually subscribes via Clerk\r\n          usage: {\r\n            current: currentUsage,\r\n            limit: planLimit,\r\n            resetDate: new Date(now.getFullYear(), now.getMonth() + 1, 1).toISOString() // Next month\r\n          },\r\n          plan: {\r\n            name: planName,\r\n            slug: planName.toLowerCase().replace(' ', '_')\r\n          }\r\n        }, { headers: corsHeaders });\r\n      } catch (error) {\r\n        console.error('Subscription endpoint error:', error);\r\n        return Response.json({\r\n          userId,\r\n          subscription: null,\r\n          usage: { current: 0, limit: 5, resetDate: new Date().toISOString() },\r\n          plan: { name: 'Free', slug: 'free' },\r\n          error: 'Subscription data temporarily unavailable'\r\n        }, { status: 200, headers: corsHeaders });\r\n      }\r\n    }\r\n\r\n    // User history endpoint\r\n    if (path.startsWith('/api/user/') && path.endsWith('/history') && request.method === 'GET') {\r\n      try {\r\n        const userId = path.split('/')[3];\r\n        console.log('Fetching history for user:', userId);\r\n        \r\n        // First, let's check what tables exist and what data we have\r\n        const tableCheck = await env.DB.prepare(`\r\n          SELECT name FROM sqlite_master WHERE type='table' AND name IN ('intakes', 'recommendations', 'intake_submissions')\r\n        `).all();\r\n        console.log('Available tables:', tableCheck.results?.map((t: any) => t.name) || []);\r\n\r\n        // Check if we have any data in intakes table with user_id\r\n        const intakesCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM intakes WHERE user_id = ?\r\n        `).bind(userId).first();\r\n        console.log('Intakes with user_id:', intakesCheck?.count || 0);\r\n\r\n        // Check if we have any data in recommendations table with user_id\r\n        const recommendationsCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM recommendations WHERE user_id = ?\r\n        `).bind(userId).first();\r\n        console.log('Recommendations with user_id:', recommendationsCheck?.count || 0);\r\n\r\n        // Check intake_submissions table (legacy compatibility)\r\n        const intakeSubmissionsCheck = await env.DB.prepare(`\r\n          SELECT COUNT(*) as count FROM intake_submissions\r\n        `).first();\r\n        console.log('Total intake_submissions:', intakeSubmissionsCheck?.count || 0);\r\n\r\n        // Try to get recommendations from the current structure\r\n        const recommendations = await env.DB.prepare(`\r\n          SELECT \r\n            recommendation_id as id,\r\n            created_at as timestamp,\r\n            'recommendation' as type,\r\n            fit_json,\r\n            COUNT(*) as carrier_count,\r\n            AVG(fit_score) as avg_fit\r\n          FROM recommendations\r\n          WHERE user_id = ? AND recommendation_id IS NOT NULL\r\n          GROUP BY recommendation_id\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).bind(userId).all();\r\n\r\n        console.log('Found recommendations:', recommendations.results?.length || 0);\r\n\r\n        // Try to get intakes from the current structure\r\n        const intakes = await env.DB.prepare(`\r\n          SELECT \r\n            id,\r\n            created_at as timestamp,\r\n            'intake' as type,\r\n            'Intake submitted' as title,\r\n            payload_json as intake_data\r\n          FROM intakes\r\n          WHERE user_id = ?\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).bind(userId).all();\r\n\r\n        console.log('Found intakes:', intakes.results?.length || 0);\r\n\r\n        // Also try intake_submissions table as fallback\r\n        const intakeSubmissions = await env.DB.prepare(`\r\n          SELECT \r\n            id,\r\n            created_at as timestamp,\r\n            'intake' as type,\r\n            'Intake submitted' as title,\r\n            data as intake_data\r\n          FROM intake_submissions\r\n          ORDER BY created_at DESC\r\n          LIMIT 50\r\n        `).all();\r\n\r\n        console.log('Found intake_submissions:', intakeSubmissions.results?.length || 0);\r\n\r\n        // Combine and format history\r\n        const history = [];\r\n        \r\n            // Add recommendations\r\n            if (recommendations.results) {\r\n              for (const rec of recommendations.results) {\r\n                try {\r\n                  // Parse the fit_json to get the actual recommendation data\r\n                  const fitJson = JSON.parse(rec.fit_json as string || '[]');\r\n                  const topCarrier = fitJson.length > 0 ? fitJson[0] : null;\r\n                  const carrierName = topCarrier?.carrierName || topCarrier?.carrierId || 'Unknown Carrier';\r\n                  const fitScore = topCarrier?.fitScore || Math.round(rec.avg_fit as number) || 0;\r\n                  \r\n                  history.push({\r\n                    id: rec.id as string,\r\n                    timestamp: rec.timestamp as string,\r\n                    type: rec.type as string,\r\n                    title: `${carrierName} - ${fitScore}% fit (${rec.carrier_count as number} carriers)`,\r\n                    score: fitScore,\r\n                    intakeData: null\r\n                  });\r\n                } catch (parseError) {\r\n                  // Fallback for old format\r\n                  history.push({\r\n                    id: rec.id as string,\r\n                    timestamp: rec.timestamp as string,\r\n                    type: rec.type as string,\r\n                    title: `Recommendation - ${Math.round(rec.avg_fit as number)}% fit (${rec.carrier_count as number} carriers)`,\r\n                    score: Math.round(rec.avg_fit as number),\r\n                    intakeData: null\r\n                  });\r\n                }\r\n              }\r\n            }\r\n\r\n            // Add intakes\r\n            if (intakes.results) {\r\n              for (const intake of intakes.results) {\r\n                history.push({\r\n                  id: intake.id as string,\r\n                  timestamp: intake.timestamp as string,\r\n                  type: intake.type as string,\r\n                  title: intake.title as string,\r\n                  score: null,\r\n                  intakeData: intake.intake_data ? JSON.parse(intake.intake_data as string) : null\r\n                });\r\n              }\r\n            }\r\n\r\n        // Add intake_submissions as fallback\r\n        if (intakeSubmissions.results && history.length === 0) {\r\n          for (const intake of intakeSubmissions.results) {\r\n            history.push({\r\n              id: intake.id,\r\n              timestamp: intake.timestamp,\r\n              type: intake.type,\r\n              title: intake.title,\r\n              score: null,\r\n              intakeData: intake.intake_data ? JSON.parse(intake.intake_data) : null\r\n            });\r\n          }\r\n        }\r\n\r\n            // Sort by timestamp (newest first)\r\n            history.sort((a: any, b: any) => new Date(b.timestamp as string).getTime() - new Date(a.timestamp as string).getTime());\r\n\r\n        console.log('Returning history with', history.length, 'items');\r\n        console.log('History items:', JSON.stringify(history, null, 2));\r\n        return Response.json(history, { headers: corsHeaders });\r\n      } catch (error) {\r\n        console.error('History endpoint error:', error);\r\n        return Response.json([], { headers: corsHeaders });\r\n      }\r\n    }\r\n    \r\n    if (path === '/api/intake/submit' && request.method === 'POST') {\r\n      try {\r\n        const intake = await request.json();\r\n        const intakeData = intake as any;\r\n        const userId = request.headers.get('X-User-Id') || 'anonymous';\r\n        const recommendationId = 'rec-' + Date.now();\r\n        const intakeId = 'intake-' + Date.now();\r\n        \r\n        // Log the intake for analytics and history tracking\r\n        console.log('Intake submitted:', {\r\n          userId,\r\n          recommendationId,\r\n          intakeId,\r\n          intakeType: intakeData.answers ? 'legacy' : 'orion',\r\n          timestamp: new Date().toISOString()\r\n        });\r\n\r\n        // Store intake in database\r\n        try {\r\n          console.log('Storing intake with userId:', userId, 'intakeId:', intakeId);\r\n          const result = await env.DB.prepare(`\r\n            INSERT INTO intakes (id, tenant_id, payload_json, validated, tier2_triggered, created_at, user_id)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            intakeId, \r\n            'default-tenant', // tenant_id (required field) - use same as existing records\r\n            JSON.stringify(intakeData), // payload_json\r\n            true, // validated\r\n            intakeData.tier2Triggered || false, // tier2_triggered\r\n            new Date().toISOString(), // created_at\r\n            userId // user_id\r\n          ).run();\r\n          console.log('Intake stored successfully:', result);\r\n        } catch (e) {\r\n          console.log('Could not log intake to database:', e);\r\n          console.log('Error details:', e);\r\n        }\r\n\r\n        // Generate real recommendations using RAG\r\n        const recommendations = await generateRealRecommendations(intakeData, env);\r\n        console.log('Generated recommendations:', recommendations.length);\r\n\r\n        // Store recommendations in database\r\n        try {\r\n          console.log('Storing recommendations with userId:', userId, 'intakeId:', intakeId);\r\n          const result = await env.DB.prepare(`\r\n            INSERT INTO recommendations (\r\n              id, intake_id, model_snapshot, fit_json, citations, latency_ms, created_at,\r\n              recommendation_id, user_id, carrier_id, carrier_name, fit_score\r\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n          `).bind(\r\n            crypto.randomUUID(),\r\n            intakeId, // intake_id (required)\r\n            'llama-3.1-8b-instruct', // model_snapshot\r\n            JSON.stringify(recommendations), // fit_json (required)\r\n            JSON.stringify(recommendations.flatMap(r => r.citations || [])), // citations (required)\r\n            Date.now() - parseInt(recommendationId.split('-')[1] as string), // latency_ms\r\n            new Date().toISOString(), // created_at\r\n            recommendationId, // recommendation_id\r\n            userId, // user_id\r\n            recommendations[0]?.carrierId || null, // carrier_id (first carrier)\r\n            recommendations[0]?.carrierName || null, // carrier_name (first carrier)\r\n            Math.round(recommendations.reduce((sum, r) => sum + r.fitPct, 0) / recommendations.length) // fit_score (average)\r\n          ).run();\r\n          console.log('Recommendations stored successfully:', result);\r\n        } catch (e: any) {\r\n          console.log('Could not store recommendations:', e);\r\n        }\r\n\r\n        // Calculate summary statistics\r\n        const averageFit = recommendations.length > 0 \r\n          ? Math.round(recommendations.reduce((sum, r) => sum + (r.fitScore || 0), 0) / recommendations.length)\r\n          : 0;\r\n\r\n        const topCarrierId = recommendations.length > 0 ? recommendations[0].carrierId : 'none';\r\n\r\n        // Format response in the expected format\r\n        const response = {\r\n          recommendationId,\r\n          status: 'completed',\r\n          intake: intake,\r\n          recommendations: recommendations,\r\n          top: recommendations.slice(0, 1),\r\n          premiumSuggestion: `Based on your profile, we recommend starting with a monthly premium of $${Math.round(1200 + (100 - averageFit) * 10)} for optimal coverage.`,\r\n          summary: {\r\n            averageFit,\r\n            totalCarriersEvaluated: recommendations.length,\r\n            tier2Recommended: averageFit < 70,\r\n            topCarrierId,\r\n            notes: recommendations.length > 0 ? 'Real recommendations generated using RAG system.' : 'No carriers found in database.'\r\n          },\r\n          metadata: {\r\n            processingTime: Date.now() - parseInt(recommendationId.split('-')[1]),\r\n            ragQueriesCount: 0, // No manual RAG queries\r\n            citationsFound: recommendations.reduce((sum, r) => sum + r.citations.length, 0),\r\n            modelUsed: 'llama-3.1-8b-instruct'\r\n          },\r\n          timestamp: new Date().toISOString()\r\n        };\r\n\r\n        console.log('Returning response with', recommendations.length, 'recommendations');\r\n        return Response.json(response, { headers: corsHeaders });\r\n\r\n      } catch (error) {\r\n        console.error('Intake submission error:', error);\r\n        return Response.json({\r\n          error: 'Failed to process intake',\r\n          message: (error as Error).message,\r\n          recommendationId: 'error-' + Date.now()\r\n        }, { status: 500, headers: corsHeaders });\r\n      }\r\n    }\r\n    \r\n        // Outcomes endpoint for logging application outcomes\r\n        if (path === '/api/outcomes' && request.method === 'POST') {\r\n          try {\r\n            const outcome = await request.json() as any;\r\n            const userId = request.headers.get('X-User-Id') || 'anonymous';\r\n            \r\n            console.log('Logging outcome:', { userId, outcome });\r\n            \r\n            // Store outcome in database\r\n            try {\r\n              await env.DB.prepare(`\r\n                INSERT INTO outcomes (id, user_id, recommendation_id, carrier_id, status, created_at)\r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n              `).bind(\r\n                crypto.randomUUID(),\r\n                userId,\r\n                outcome.recommendationId || null,\r\n                outcome.carrierId || null,\r\n                outcome.status || 'applied',\r\n                new Date().toISOString()\r\n              ).run();\r\n            } catch (e: any) {\r\n              console.log('Could not log outcome to database:', e);\r\n            }\r\n            \r\n            return Response.json({ success: true, message: 'Outcome logged successfully' }, { headers: corsHeaders });\r\n          } catch (error) {\r\n            console.error('Outcomes endpoint error:', error);\r\n            return Response.json({ error: 'Failed to log outcome' }, { status: 500, headers: corsHeaders });\r\n          }\r\n        }\r\n\r\n        // Recommendations endpoint for retrieving specific recommendations\r\n        if (path.startsWith('/api/recommendations/') && request.method === 'GET') {\r\n          try {\r\n            const recommendationId = path.split('/')[3];\r\n            const userId = request.headers.get('X-User-Id');\r\n            \r\n            console.log('Fetching recommendation:', recommendationId, 'for user:', userId);\r\n            \r\n            // Get recommendation data from database\r\n            const recs = await env.DB.prepare(`\r\n              SELECT * FROM recommendations\r\n              WHERE recommendation_id = ?\r\n                AND user_id = ?\r\n            `).bind(recommendationId, userId).all();\r\n\r\n            if (recs?.results && recs.results.length > 0) {\r\n              // Parse the stored recommendation data\r\n              const storedData = recs.results[0];\r\n              const fitJson = JSON.parse(storedData.fit_json || '[]');\r\n              \r\n              const recommendations = fitJson.map((rec: any) => {\r\n                // Handle both new and old data formats\r\n                const fitScore = rec.fitScore || rec.fitPct || rec.fitPercent || 0;\r\n                const carrierName = rec.carrierName || rec.carrierId || 'Unknown Carrier';\r\n                const product = rec.product || rec.program || 'Life Insurance';\r\n                const reasons = rec.reasoning?.pros || rec.reasons || [`${carrierName} underwriting guidelines applicable`];\r\n                const advisories = rec.reasoning?.cons || rec.advisories || [];\r\n                const citations = rec.citations || [];\r\n                \r\n                return {\r\n                  carrierId: rec.carrierId || 'unknown',\r\n                  carrierName: carrierName,\r\n                  program: product,\r\n                  fitScore: fitScore,\r\n                  fitPct: fitScore, // For backward compatibility\r\n                  tier: fitScore >= 85 ? 'preferred' : fitScore >= 70 ? 'standard' : 'challenging',\r\n                  reasoning: {\r\n                    pros: reasons,\r\n                    cons: advisories,\r\n                    summary: `Fit score of ${fitScore}% based on underwriting criteria.`\r\n                  },\r\n                  estimatedPremium: {\r\n                    monthly: Math.round(1200 + (100 - fitScore) * 10),\r\n                    annual: Math.round((1200 + (100 - fitScore) * 10) * 12),\r\n                    confidence: rec.confidence || 'medium'\r\n                  },\r\n                  underwritingPath: fitScore >= 80 ? 'simplified' : 'standard',\r\n                  requiresExam: rec.apsLikely || false,\r\n                  processingTime: fitScore >= 80 ? '1-2 weeks' : '2-3 weeks',\r\n                  citations: citations\r\n                };\r\n              });\r\n\r\n              const averageFit = recommendations.length > 0 \r\n                ? Math.round(recommendations.reduce((sum: number, r: any) => sum + r.fitScore, 0) / recommendations.length)\r\n                : 0;\r\n\r\n              return Response.json({\r\n                recommendationId,\r\n                status: 'completed',\r\n                recommendations,\r\n                top: recommendations.slice(0, 1),\r\n                premiumSuggestion: `Based on your profile, we recommend starting with a monthly premium of $${Math.round(1200 + (100 - averageFit) * 10)} for optimal coverage.`,\r\n                summary: {\r\n                  averageFit,\r\n                  totalCarriersEvaluated: recommendations.length,\r\n                  tier2Recommended: averageFit < 70,\r\n                  topCarrierId: recommendations[0]?.carrierId || 'none',\r\n                  notes: 'Recommendation retrieved from database.'\r\n                },\r\n                metadata: {\r\n                  processingTime: storedData.latency_ms || 0,\r\n                  citationsFound: recommendations.reduce((sum: number, r: any) => sum + r.citations.length, 0),\r\n                  modelUsed: storedData.model_snapshot || 'llama-3.1-8b-instruct'\r\n                },\r\n                timestamp: storedData.created_at\r\n              }, { headers: corsHeaders });\r\n            } else {\r\n              return Response.json({\r\n                error: 'Recommendation not found',\r\n                recommendationId\r\n              }, { status: 404, headers: corsHeaders });\r\n            }\r\n          } catch (error) {\r\n            console.error('Recommendation retrieval error:', error);\r\n            return Response.json({\r\n              error: 'Failed to retrieve recommendation',\r\n              message: (error as Error).message\r\n            }, { status: 500, headers: corsHeaders });\r\n          }\r\n        }\r\n        \r\n        return Response.json({ error: 'Not found' }, { status: 404, headers: corsHeaders });\r\n      }\r\n    };"],
  "mappings": "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",
  "names": ["generateEmbedding"]
}
